#!/usr/bin/perl

# NOTE! This script is designed to be executed within Atlas V only!

# Periodically scan hosts.

# Switches: 
#	Check interface status, vlans and MAC addresses. 
#	Backup config every 24 hours. 
#	Detect loops and other disrepancies.

# Routers:
#	Check interface status and routing information.
#	Backup config every 24 hours.
#	Detect possible problems.

# UPS:
#	Check bypass and battery status


#$ snmpwalk -c public -v 1 $IP_ADDRESS $OID
# Cisco	 1.3.6.1.4.1.9 
# https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers


#$ snmpwalk -c public -v 1 10.113.10.30 1.3.6.1.2.1.33 -m /usr/share/snmp/mibs/STDUPSV1.txt
# Eaton 5P
# MGE UPS SYSTEMS GALAXY 5000 60 kVA
#
# input ON, output ON
# host=7, snmp_name=upsBatteryStatus, suffix=1, value=2 (normal)
# host=7, snmp_name=upsOutputSource, suffix=1, value=3 (normal)
# host=7, snmp_name=upsAlarmsPresent, suffix=1, value=0
#
# input ON, output OFF
# host=7, snmp_name=upsBatteryStatus, suffix=1, value=2 (normal)
# host=7, snmp_name=upsOutputSource, suffix=1, value=2 (none)
# host=7, snmp_name=upsAlarmsPresent, suffix=1, value=(greater than 0)
#
# input OFF, output ON
# host=7, snmp_name=upsBatteryStatus, suffix=1, value=2 (normal)
# host=7, snmp_name=upsOutputSource, suffix=1, value=5 (battery)
# host=7, snmp_name=upsAlarmsPresent, suffix=1, value=(greater than 0)
#
# input OFF, output OFF
# no response
#
# Raise alarm if status != 2 or source != 3 or alarms > 0


#$ snmpwalk -c public -v 1 10.132.10.32 1.3.6.1.4.1.318 -m /usr/share/snmp/mibs/powernet417.txt 
# Smart-UPS RT 3000 XL
#
# upsBasicBatteryStatus.0 = INTEGER: batteryNormal(2)
# upsBasicOutputStatus.0 = INTEGER: onLine(2)
# upsAdvStateSystemMessages.0 = "" # 3 digit Decimal code representing the current active message


use strict;
use warnings;
#use Net::SNMP;
use SNMP::Effective;
use Time::HiRes;
use Data::Dumper;
use JSON;

my %oids = qw(
  ifIndex                   1.3.6.1.2.1.2.2.1.1          
  ifName                    1.3.6.1.2.1.31.1.1.1.1       
  vtpVlanState              1.3.6.1.4.1.9.9.46.1.3.1.1.2 
  dot1dTpFdbPort            1.3.6.1.2.1.17.4.3.1.2       
  dot1dBasePortIfIndex      1.3.6.1.2.1.17.1.4.1.2       
  ifVlan                    1.3.6.1.4.1.9.9.68.1.2.2.1.2 
  ifAlias                   1.3.6.1.2.1.31.1.1.1.18      
  ifHighSpeed               1.3.6.1.2.1.31.1.1.1.15      
  ifAdminStatus             1.3.6.1.2.1.2.2.1.7          
  ifOperStatus              1.3.6.1.2.1.2.2.1.8          
  ipNetToMediaPhysAddress   1.3.6.1.2.1.4.22.1.2         

  upsBatteryStatus          1.3.6.1.2.1.33.1.2.1
  upsOutputSource           1.3.6.1.2.1.33.1.4.1
  upsAlarmsPresent          1.3.6.1.2.1.33.1.6.1

  upsBasicBatteryStatus     1.3.6.1.4.1.318.1.1.1.2.1.1
  upsBasicOutputStatus      1.3.6.1.4.1.318.1.1.1.4.1.1
  upsAdvStateSystemMessages 1.3.6.1.4.1.318.1.1.1.11.2.6
);
my %r_oids = reverse %oids;

#my $json = JSON->new( allow_nonref => 1 );
my $json = JSON->new();
warn "$0 $$ running\n";
while (1) {

  # Fetch list of hosts to scan
  print $session "SELECT id,ip FROM hosts WHERE disabled = false AND scanned IS NULL OR scanned < DATE_SUB(NOW(), INTERVAL 1 HOUR)\n";
  my @hosts = query_result($session);
  my %host_ip_by_id = map { $_->{'id'} => $_->{'ip'} } @hosts; 
  my %host_id_by_ip = map { $_->{'ip'} => $_->{'id'} } @hosts;
  

#  # Fetch SNMP OIDs to try
#  print $session "SELECT name,oid FROM snmp_oids\n";
#  my @oids = query_result($session);
#  my %snmp_name_by_oid = map { $_->{'oid'} => $_->{'name'} } @oids;
#  my %snmp_oid_by_name = map { $_->{'name'} => $_->{'oid'} } @oids;
  
  my $snmp = SNMP::Effective->new(
    MaxSessions   => 32,
    MasterTimeout => 240,
    DestHost      => [ values %host_ip_by_id ],
    Arg           => {
      Community   => 'public',
      Version     => 1,
      RemotePort  => 161,
      Timeout     => '1000000', # microseconds
      Retries     => 3,
      RetryNoSuch => 0,
    },
    Callback      => sub { 
      my $host = shift;
      my $error = shift;
      
      if ($error) { 
        warn "$host: $error\n"; 
        return;
      }
      
      # Process SNMP data returned by $host
      my $host_id = $host_id_by_ip{$host};
      foreach my $prefix (sort by_dots keys %{$host->data}) {
        my $snmp_name = $r_oids{$prefix};
        $host->data->{$snmp_name} = $host->data->{$prefix};
        # DEBUG
        next unless $snmp_name =~ 'ups';
        foreach my $suffix (sort by_dots keys %{$host->data->{$snmp_name}}) {
          my $value = $host->data->{$snmp_name}->{$suffix};
          warn "host=$host_id, snmp_name=$snmp_name, suffix=$suffix, value=$value\n";
        }
      }

      # Extract ARP table data (ifIndex.a.b.c.d = CCCCCC)
      foreach my $suffix (sort by_dots keys %{$host->data->{'ipNetToMediaPhysAddress'}}) {
        my ($ifindex, @octets) = split(/\./, $suffix, 5);
        my $ifname = $host->data->{'ifName'}->{$ifindex};
        my $inet = join('.', @octets);
        # Convert the six ASCII characters to MAC address format e.g "01:23:45:67:89:ab"
        my $mac = join(':', map { unpack('h*', $_) } split(//, $host->data->{'ipNetToMediaPhysAddress'}->{$suffix}) );
#        warn "$host> ARP $inet via $ifname at $mac\n";
      }
      
      # Extract MAC forwarding data (n.n.n.n.n.n = port)
      foreach my $suffix (sort by_dots keys %{$host->data->{'dot1dTpFdbPort'}}) {
        my $mac = mac_from_dots($suffix);
        my $port = $host->data->{'dot1dTpFdbPort'}->{$suffix};
        my $ifindex = $host->data->{'dot1dBasePortIfIndex'}->{$port};
        my $ifname = $host->data->{'ifName'}->{$ifindex};
        my $ifvlan = $host->data->{'ifVlan'}->{$ifindex} || 0; # undef = no vlan, e.g trunk
#        warn "$host> MAC $mac ifname=$ifname ifvlan=$ifvlan\n";
      }

      # Extract port information (ifIndex = ifIndex)
      foreach my $ifindex (sort by_dots keys %{$host->data->{'ifIndex'}}) {
        my $ifname = $host->data->{'ifName'}->{$ifindex};
        my $ifvlan = $host->data->{'ifVlan'}->{$ifindex} || 0; # undef = no vlan, e.g trunk
        my $ifspeed = $host->data->{'ifHighSpeed'}->{$ifindex};
        my $ifalias = $host->data->{'ifAlias'}->{$ifindex};
        my $ifadmin = $host->data->{'ifAdminStatus'}->{$ifindex};
        my $ifoper = $host->data->{'ifOperStatus'}->{$ifindex};
#        warn "$host> PORT $ifname speed=$ifspeed vlan=$ifvlan alias=$ifalias admin=$ifadmin oper=$ifoper\n";
      }
              
    },
    walk          => [ values %oids ],
  );

  $snmp->execute();
  
  
#  foreach my $record (@records) {
#    #warn "$0 $$ scan host id=".$record->{'id'}." ip=".$record->{'ip'}."\n";
#
#    # Scan host
#    # ...
#
#    print $session "UPDATE hosts SET scanned=NOW() WHERE id=".int($record->{'id'})."\n";
#    query_result($session);
#  }

  my $now = time;
  my $interval = 60;
  my $delta = $interval - ($now % $interval);
  warn "Time: $now -> will sleep $delta seconds\n";
  sleep ($delta);

}


sub query_result {
  my $session = shift;
  my $cols = [];
  my @records = ();
  while (my $line = <$session>) {
    chomp $line;
    last unless $line; # Empty line = end of response
    next if $line =~ /^#/; # Comment/message
    if ($line =~ /^\!/) {
      # Error
      warn "$0 $$ $line\n";
      last;
    }
    #warn "$0 $$ decode line=".$line."\n";
    if ($line =~ /^\@(.+)/) { $cols = $json->decode($1); next; }
    my $row = $json->decode($line);
    my %hash = ();
    @hash{@{$cols}} = @{$row}; 
    push @records, \%hash;
    #warn "$0 $$ hash=".Dumper(\%hash);
  } 
  return @records;
}


# Usage: sort by_dots ARRAY
# ARRAY must contain strings of numbers separated by dots, eg. IP addresses or SNMP OIDs
sub by_dots {

  # Split by dots
  my @a = split(/\./, $a);
  my @b = split(/\./, $b);
  
  # Compare numerically until a difference is found
  while (@a || @b) {
    my $n1 = shift @a || 0;
    my $n2 = shift @b || 0;
    return -1 if ($n1 < $n2);
    return  1 if ($n1 > $n2);  
  }

  # ...or return 0 if no difference
  return 0;
}


# Usage: mac_from_dots('255.255.255.255.255.255') 
# Would return 'ff:ff:ff:ff:ff:ff"
sub mac_from_dots {
  my $dots = shift;
  return join(':', map { sprintf('%02x', $_) } split(/\./, $dots) );
}

