#!/usr/bin/perl

# NOTE! This script is designed to be executed within Atlas V only!

# Periodically scan hosts.

# Switches: 
#	Check interface status, vlans and MAC addresses. 
#	Backup config every 24 hours. 
#	Detect loops and other disrepancies.

# Routers:
#	Check interface status and routing information.
#	Backup config every 24 hours.
#	Detect possible problems.

# UPS:
#	Check bypass and battery status


#$ snmpwalk -c public -v 1 $IP_ADDRESS $OID
# Cisco	 1.3.6.1.4.1.9 
# https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers


#$ snmpwalk -c public -v 1 10.113.10.30 1.3.6.1.2.1.33 -m /usr/share/snmp/mibs/STDUPSV1.txt
# Eaton 5P
# MGE UPS SYSTEMS GALAXY 5000 60 kVA
#
# input ON, output ON
# host=7, snmp_name=upsBatteryStatus, suffix=1, value=2 (normal)
# host=7, snmp_name=upsOutputSource, suffix=1, value=3 (normal)
# host=7, snmp_name=upsAlarmsPresent, suffix=1, value=0
#
# input ON, output OFF
# host=7, snmp_name=upsBatteryStatus, suffix=1, value=2 (normal)
# host=7, snmp_name=upsOutputSource, suffix=1, value=2 (none)
# host=7, snmp_name=upsAlarmsPresent, suffix=1, value=(greater than 0)
#
# input OFF, output ON
# host=7, snmp_name=upsBatteryStatus, suffix=1, value=2 (normal)
# host=7, snmp_name=upsOutputSource, suffix=1, value=5 (battery)
# host=7, snmp_name=upsAlarmsPresent, suffix=1, value=(greater than 0)
#
# input OFF, output OFF
# no response
#
# Raise alarm if status != 2 or source != 3 or alarms > 0


#$ snmpwalk -c public -v 1 10.132.10.32 1.3.6.1.4.1.318 -m /usr/share/snmp/mibs/powernet417.txt 
# Smart-UPS RT 3000 XL
#
# upsBasicBatteryStatus.0 = INTEGER: batteryNormal(2)
# upsBasicOutputStatus.0 = INTEGER: onLine(2)
# upsAdvStateSystemMessages.0 = "" # 3 digit Decimal code representing the current active message


use strict;
use warnings;
#use Net::SNMP;
use SNMP::Effective;
use Time::HiRes;
use Data::Dumper;
use JSON;
use DBI;
use AtlasV;

my $dbh = DBI->connect(AtlasV::db());
unless ($dbh) {
  confess "Error: ".$DBI::errstr;
}
$dbh->{'mysql_auto_reconnect'} = 1;


my %oids = qw(
  ifIndex                   1.3.6.1.2.1.2.2.1.1          
  ifName                    1.3.6.1.2.1.31.1.1.1.1       
  vtpVlanState              1.3.6.1.4.1.9.9.46.1.3.1.1.2 
  dot1dTpFdbPort            1.3.6.1.2.1.17.4.3.1.2       
  dot1dBasePortIfIndex      1.3.6.1.2.1.17.1.4.1.2       
  ifVlan                    1.3.6.1.4.1.9.9.68.1.2.2.1.2 
  ifAlias                   1.3.6.1.2.1.31.1.1.1.18      
  ifHighSpeed               1.3.6.1.2.1.31.1.1.1.15      
  ifAdminStatus             1.3.6.1.2.1.2.2.1.7          
  ifOperStatus              1.3.6.1.2.1.2.2.1.8          
  ipNetToMediaPhysAddress   1.3.6.1.2.1.4.22.1.2         

  upsBatteryStatus          1.3.6.1.2.1.33.1.2.1
  upsOutputSource           1.3.6.1.2.1.33.1.4.1
  upsAlarmsPresent          1.3.6.1.2.1.33.1.6.1

  upsBasicBatteryStatus     1.3.6.1.4.1.318.1.1.1.2.1.1
  upsBasicOutputStatus      1.3.6.1.4.1.318.1.1.1.4.1.1
  upsAdvStateSystemMessages 1.3.6.1.4.1.318.1.1.1.11.2.6
);
my %r_oids = reverse %oids;

my $lifetime = '7 DAY'; # https://www.w3schools.com/sql/func_mysql_date_sub.asp

#my $json = JSON->new( allow_nonref => 1 );
my $json = JSON->new();
warn "$0 $$ running\n";
while (1) {

  # Expire data
  print $session "DELETE FROM macsightings WHERE recorded < DATE_SUB(NOW(), INTERVAL $lifetime)\n";
  { my @res = query_result($session); }
  print $session "DELETE FROM arpsightings WHERE recorded < DATE_SUB(NOW(), INTERVAL $lifetime)\n";
  { my @res = query_result($session); }

  # Fetch list of hosts to scan
  print $session "SELECT id,ip FROM hosts WHERE disabled = false AND scanned IS NULL OR scanned < DATE_SUB(NOW(), INTERVAL 1 HOUR)\n";
  my @hosts = query_result($session);
  my %host_ip_by_id = map { $_->{'id'} => $_->{'ip'} } @hosts; 
  my %host_id_by_ip = map { $_->{'ip'} => $_->{'id'} } @hosts;
  

#  # Fetch SNMP OIDs to try
#  print $session "SELECT name,oid FROM snmp_oids\n";
#  my @oids = query_result($session);
#  my %snmp_name_by_oid = map { $_->{'oid'} => $_->{'name'} } @oids;
#  my %snmp_oid_by_name = map { $_->{'name'} => $_->{'oid'} } @oids;
  
  my $snmp = SNMP::Effective->new(
    MaxSessions   => 32,
    MasterTimeout => 240,
    DestHost      => [ values %host_ip_by_id ],
    Arg           => {
      Community   => 'public',
      Version     => 1,
      RemotePort  => 161,
      Timeout     => '1000000', # microseconds
      Retries     => 3,
      RetryNoSuch => 0,
    },
    Callback      => sub { 
      my $host = shift;
      my $error = shift;
      
      if ($error) { 
        warn "$host: $error\n"; 
        return;
      }
      
      # Process SNMP data returned by $host
      my $host_id = $host_id_by_ip{$host};
      foreach my $prefix (sort by_dots keys %{$host->data}) {
        my $snmp_name = $r_oids{$prefix};
        $host->data->{$snmp_name} = $host->data->{$prefix};
        # DEBUG
        next unless $snmp_name =~ 'ups';
        foreach my $suffix (sort by_dots keys %{$host->data->{$snmp_name}}) {
          my $value = $host->data->{$snmp_name}->{$suffix};
          warn "host=$host_id, snmp_name=$snmp_name, suffix=$suffix, value=$value\n";
        }
      }

      # Extract port information (ifIndex = ifIndex)
      {
        # Lexical scope for the statement handlers
        my $vlan_insert_sth = $dbh->prepare('INSERT INTO vlans (id) VALUES (?)');
        my $port_insert_sth = $dbh->prepare('INSERT IGNORE INTO ports (name,host) VALUES (?,?)');
        my $port_select_sth = $dbh->prepare('SELECT id FROM ports WHERE name=? AND host=?');
        my $port_update_sth = $dbh->prepare('UPDATE ports SET `index`=?, up=?, admin=?, speed=?, vlan=?, description=? WHERE id=?');
        foreach my $ifindex (sort by_dots keys %{$host->data->{'ifIndex'}}) {
          my $ifname = $host->data->{'ifName'}->{$ifindex};
          my $ifvlan = $host->data->{'ifVlan'}->{$ifindex} || 0; # undef = no vlan, e.g trunk
          my $ifspeed = $host->data->{'ifHighSpeed'}->{$ifindex};
          my $ifalias = $host->data->{'ifAlias'}->{$ifindex};
          my $ifadmin = $host->data->{'ifAdminStatus'}->{$ifindex};
          my $ifoper = $host->data->{'ifOperStatus'}->{$ifindex};
          #warn "$host> PORT $ifname speed=$ifspeed vlan=$ifvlan alias=$ifalias admin=$ifadmin oper=$ifoper\n";

          # Ensure vlan exists in database
          $vlan_insert_sth->execute($ifvlan);
          
          # Get unique id for this interface port
          $port_insert_sth->execute($ifname, $host_id);
          $port_select_sth->execute($ifname, $host_id);
          my $port_id = $port_select_sth->fetchrow_hashref->{'id'};
          warn "WARNING! port id undefined while updating port, should not be possible\n" unless defined $port_id;

          # Update port information
          $port_update_sth->execute($ifindex, $ifoper, $ifadmin, $ifspeed, $ifvlan, $ifalias, $port_id);
          warn $dbh->errstr if $dbh->errstr;
        }
        $vlan_insert_sth->finish;
        $port_insert_sth->finish;
        $port_select_sth->finish;
        $port_update_sth->finish;
        
      }

      # Extract ARP table data (ifIndex.a.b.c.d = CCCCCC)
      {
        # Lexical scope for the statement handlers
        my $mac_insert_sth = $dbh->prepare('INSERT IGNORE INTO macs (address) VALUES (?)');
        my $mac_select_sth = $dbh->prepare('SELECT id FROM macs WHERE address=?');
        my $port_insert_sth = $dbh->prepare('INSERT IGNORE INTO ports (name,host) VALUES (?,?)');
        my $port_select_sth = $dbh->prepare('SELECT id FROM ports WHERE name=? AND host=?');
        my $arp_insert_sth = $dbh->prepare('INSERT INTO arpsightings (mac,ip,port) VALUES (?,?,?)');
        foreach my $suffix (sort by_dots keys %{$host->data->{'ipNetToMediaPhysAddress'}}) {
          my ($ifindex, @octets) = split(/\./, $suffix, 5);
          my $ifname = $host->data->{'ifName'}->{$ifindex};
          my $inet = join('.', @octets);
          # Convert the six ASCII characters to MAC address format e.g "01:23:45:67:89:ab"
          my $mac = join(':', map { unpack('h*', $_) } split(//, $host->data->{'ipNetToMediaPhysAddress'}->{$suffix}) );
          #warn "$host> ARP $inet via $ifname at $mac\n";
          
          # Get (or allocate) unique id for this MAC address
          $mac_insert_sth->execute($mac);
          $mac_select_sth->execute($mac);
          my $mac_id = $mac_select_sth->fetchrow_hashref->{'id'};
          warn "WARNING! mac id undefined while recording ARP, should not be possible\n" unless defined $mac_id;
          
          # Get unique id for this interface port
          $port_insert_sth->execute($ifname, $host_id);
          $port_select_sth->execute($ifname, $host_id);
          my $port_id = $port_select_sth->fetchrow_hashref->{'id'};
          warn "WARNING! port id undefined while recording ARP, should not be possible\n" unless $port_id;
          
          # Record ARP IP address sighting with port
          $arp_insert_sth->execute($mac_id, $inet, $port_id);
          
        }
        $mac_insert_sth->finish;
        $mac_select_sth->finish;
        $port_insert_sth->finish;
        $port_select_sth->finish;
        $arp_insert_sth->finish;
      }
      
      # Extract MAC forwarding data (n.n.n.n.n.n = port)
      {
        # Lexical scope for the statement handlers
        my $vlan_insert_sth = $dbh->prepare('INSERT INTO vlans (id) VALUES (?)');
        my $mac_insert_sth = $dbh->prepare('INSERT IGNORE INTO macs (address) VALUES (?)');
        my $mac_select_sth = $dbh->prepare('SELECT id FROM macs WHERE address=?');
        my $port_insert_sth = $dbh->prepare('INSERT IGNORE INTO ports (name,host) VALUES (?,?)');
        my $port_select_sth = $dbh->prepare('SELECT id FROM ports WHERE name=? AND host=?');
        my $macsighting_insert_sth = $dbh->prepare('INSERT INTO macsightings (mac,vlan,port) VALUES (?,?,?)');
        foreach my $suffix (sort by_dots keys %{$host->data->{'dot1dTpFdbPort'}}) {
          my $mac = mac_from_dots($suffix);
          my $port = $host->data->{'dot1dTpFdbPort'}->{$suffix};
          my $ifindex = $host->data->{'dot1dBasePortIfIndex'}->{$port};
          my $ifname = $host->data->{'ifName'}->{$ifindex};
          my $ifvlan = $host->data->{'ifVlan'}->{$ifindex} || 0; # undef = no vlan, e.g trunk
          #warn "$host> MAC $mac ifname=$ifname ifvlan=$ifvlan\n";
          
          # Get (or allocate) unique id for this MAC address
          $mac_insert_sth->execute($mac);
          $mac_select_sth->execute($mac);
          my $mac_id = $mac_select_sth->fetchrow_hashref->{'id'};
          warn "WARNING! mac id undefined while recording MAC sighting, should not be possible\n" unless defined $mac_id;
        
          # Get unique id for this interface port
          $port_insert_sth->execute($ifname, $host_id);
          $port_select_sth->execute($ifname, $host_id);
          my $port_id = $port_select_sth->fetchrow_hashref->{'id'};
          warn "WARNING! port id undefined while recording MAC sighting, should not be possible\n" unless defined $port_id;          
          
          # Ensure vlan ID exists in database
          $vlan_insert_sth->execute($ifvlan);

          # Record MAC sighting with vlan/port
          $macsighting_insert_sth->execute($mac_id, $ifvlan, $port_id);
          
        }
        $mac_insert_sth->finish;
        $mac_select_sth->finish;
        $port_insert_sth->finish;
        $port_select_sth->finish;
        $vlan_insert_sth->finish;
        $macsighting_insert_sth->finish;
      }

                    
    },
    walk          => [ values %oids ],
  );

  $snmp->execute();
  
  
#  foreach my $record (@records) {
#    #warn "$0 $$ scan host id=".$record->{'id'}." ip=".$record->{'ip'}."\n";
#
#    # Scan host
#    # ...
#
#    print $session "UPDATE hosts SET scanned=NOW() WHERE id=".int($record->{'id'})."\n";
#    query_result($session);
#  }

  my $now = time;
  my $interval = 60;
  my $delta = $interval - ($now % $interval);
  warn "Time: $now -> will sleep $delta seconds\n";
  sleep ($delta);

}


sub query_result {
  my $session = shift;
  my $cols = [];
  my @records = ();
  while (my $line = <$session>) {
    chomp $line;
    last unless $line; # Empty line = end of response
    next if $line =~ /^#/; # Comment/message
    if ($line =~ /^\!/) {
      # Error
      warn "$0 $$ $line\n";
      last;
    }
    #warn "$0 $$ decode line=".$line."\n";
    if ($line =~ /^\@(.+)/) { $cols = $json->decode($1); next; }
    my $row = $json->decode($line);
    my %hash = ();
    @hash{@{$cols}} = @{$row}; 
    push @records, \%hash;
    #warn "$0 $$ hash=".Dumper(\%hash);
  } 
  return @records;
}


# Usage: sort by_dots ARRAY
# ARRAY must contain strings of numbers separated by dots, eg. IP addresses or SNMP OIDs
sub by_dots {

  # Split by dots
  my @a = split(/\./, $a);
  my @b = split(/\./, $b);
  
  # Compare numerically until a difference is found
  while (@a || @b) {
    my $n1 = shift @a || 0;
    my $n2 = shift @b || 0;
    return -1 if ($n1 < $n2);
    return  1 if ($n1 > $n2);  
  }

  # ...or return 0 if no difference
  return 0;
}


# Usage: mac_from_dots('255.255.255.255.255.255') 
# Would return 'ff:ff:ff:ff:ff:ff"
sub mac_from_dots {
  my $dots = shift;
  return join(':', map { sprintf('%02x', $_) } split(/\./, $dots) );
}

